% Created 2023-10-17 Tue 22:42
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Michel Donnet}
\date{\today}
\title{TP2 MPI}
\hypersetup{
 pdfauthor={Michel Donnet},
 pdftitle={TP2 MPI},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.1 (Org mode 9.6.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Explication des algorithmes}
\label{sec:org5190fb3}

\subsection{Diffusion séquentielle}
\label{sec:orgab208b1}

Le principe de cet algorithme est qu'il n'y a qu'un seul processeur qui envoie un message à tous les autres processeurs.

\subsection{Anneau séquentiel}
\label{sec:orga0b11fc}

Le principe de cet algorithme est que chaque processeur envoie un message au processeur de rang supérieur à lui modulo nombre de processeurs (Si N est le nombre de processeurs,
alors le processeur N - 1 va envoyer un message au processeur N modulo N = 0 \ldots{} Ainsi on fait une boucle). Et il recevra un message du processeur
de rang inférieur à lui modulo nombre de processeurs (si on est le processeur 0, on va recevoir un message du processeur -1 modulo N = N - 1\ldots{})

\subsection{Diffusion HyperCube}
\label{sec:orge5be3e8}

Le principe de cet algorithme est que chaque processeur échange avec le processeur dont le rang diffère de son rang de seulement un seul bit, et ainsi de suite\ldots{}

On introduit donc un masque et on fait une opération de xor entre le rang du processeur et le masque, ce qui donne le rang du processeur différant de seulement un bit
du rang du processeur courant. Si le rang de ce processeur est plus petit que le rang du processeur courant, on envoie un message à ce processeur, sinon on reçoit un message
de ce processeur.

\newpage

\section{Explication du code}
\label{sec:org8850e8c}

Dans tout notre code, j'ai défini \(world\_size = N\) qui est le nombre de processeurs utilisés par le programme.
Ensuite, chaque processeur est numéroté de 0 à \((N - 1)\). Le numéro du processeur est dans notre cas unique et
se trouve dans la variable \(world\_rank\) de mon code.

\subsection{Diffusion séquentielle}
\label{sec:org0e6d1f0}
\begin{verbatim}
if (world_rank == 0) {
        for (int i = 1; i < world_size; i++) {
                  MPI_Send(text, size, MPI_CHAR, i, 0, MPI_COMM_WORLD);
        }
}
else {
        char buffer[MAX_BUFFER];
        MPI_Recv(buffer, MAX_BUFFER, MPI_CHAR, 0, 0, MPI_COMM_WORLD, &status);
        printf("Your message");
}

\end{verbatim}

À la première ligne de notre code, on regarde si on est le processeur de rang 0.
Si c'est le cas, on envoie à tous les autres processeurs un message.
Sinon, cela signifie qu'on n'est pas le processeur de rang 0, donc on lit le message envoyé
par le processeur 0 et on affiche quelque chose.

\subsection{Anneau séquentiel}
\label{sec:org1329913}
\begin{verbatim}
MPI_Send(text, size, MPI_CHAR, (world_rank + 1) % world_size, 0, MPI_COMM_WORLD);
MPI_Recv(
         buffer,
         MAX_BUFFER,
         MPI_CHAR,
         (world_rank + world_size - 1) % world_size,
         0,
         MPI_COMM_WORLD,
         &status
);
printf("Your message");

\end{verbatim}
On envoie un message au processeur de rang supérieur à notre rang, et on reçoit un message du processeur de rang inférieur à notre rang.
Évidement, si N est le nombre de processeurs et qu'on est le processeur de rang N - 1, on va envoyer un message au processeur de rang 0 et 
si on est le processeur de rang 0, on va recevoir un message du processeur de rang N - 1, ce qui permet de faire justement un anneau.
C'est pour cela que je fais un modulo nombre de processeurs dans le send et le receive de mon code.

\subsection{Diffusion HyperCube}
\label{sec:org1e5f34e}
\begin{verbatim}
int mask = 1;
while (world_size > mask) {
       int process = world_rank ^ mask;
       if (process > world_rank) {
             MPI_Recv(
                      buffer,
                      MAX_BUFFER,
                      MPI_CHAR,
                      process,
                      0,
                      MPI_COMM_WORLD,
                      &status
             );
             printf("Your message");
       }
       else {
             MPI_Send(text, size, MPI_CHAR, process, 0, MPI_COMM_WORLD);
       }
       mask = mask << 1;
}
\end{verbatim}
Tout d'abord, on commence par définir un masque à 1 (cela donne en binaire \(000 \dots 1\)).
Ensuite, on boucle tant que le masque est plus petit que le nombre de processeurs\ldots{}
En effet, on va faire à la fin du while un décalage de 1 bits vers la gauche (ainsi mask va passer de \(000\dots01\) à \(000\dots10\)).
Donc si par exemple on a 6 processeurs, on aura notre \(world\_size\) qui sera égal à 6, soit \(110\) en binaire.
Et notre masque va être égal tour à tour à \(001\), puis \(010\), puis \(100\), et on sortira de la boucle while quand le masque sera égal à \(1000\),
soit quand le masque sera plus grand que notre \(world\_size\).

Ensuite, supposons qu'on a un masque \(001 = 1\) et le processeur \(010 = 2\). Le xor donnera donc \(011 = 3\), ce qui est plus grand que le numéro ou rang de notre processeur, donc on réceptionne le message
du processeur dont le rang est égal à cette valeur. Et si on a par exemple le processeur \(011 = 3\), le xor donnera \(010 = 2\), donc on envoie un message au processeur de rang \(010 = 2\).

Et à la fin de notre boucle while, on fait un décalage de 1 bits vers la gauche du masque, ce qui nous donne un masque \(010 = 2\).

\subsection{Main}
\label{sec:org9167231}

Voilà à quoi ressemble mon programme main.
\begin{verbatim}
 1  #include "exercises.h"
 2  #include <string.h>
 3  #include <iostream>
 4  
 5  using namespace std;
 6  
 7  int main(int argc, char * argv[]) {
 8          if (argc != 2) {
 9                  cerr << "Usage of the program" << endl;
10                  return -1;
11          }
12          int exercise_number = atoi(argv[1]);
13          switch (exercise_number) {
14                  case 1:
15                          exercise_1();
16                          break;
17                  case 2:
18                          exercise_2();
19                          break;
20                  case 3:
21                          exercise_3();
22                          break;
23                  default:
24                          cerr << "Usage of the program" << endl;
25                          return -1;
26          }
27          return 0;
28  }
\end{verbatim}

Dans le main, on commence par vérifier que l'utilisateur a bien entré un paramètre lorsqu'il exécute le programme (lignes 8-11). Si ce n'est pas le cas, on le fait sortir du programme et on affiche un
mode d'utilisation.

Si l'utilisateur a entré un paramètre, on le convertit en nombre (au moyen de la fonction atoi. Si elle échoue, elle retournera 0). Si on a les nombres 1, 2 ou 3, on exécutera l'exercice 1, 2 ou 3 suivant le nombre reçu,
et si l'utilisateur a donné quelque chose différent de 1, 2 ou 3, on affiche un mode d'emploi du programme et on quitte.


\section{Tests}
\label{sec:org424c017}

Pour tester mon code, j'ai simplement fait envoyer par les différents processeurs le message "Hello world !", et lorsque un processeur recevait un message, il affichait le message reçu,
son rang et le rang du processeur ayant envoyé le message. Ainsi, je vérifiais "à la main" les résultats que j'avais obtenus en regardant si c'était cohérent avec ce qui m'étais demandé\ldots{}

Mon code est composé de 3 fonctions, et il faut donner en paramètres lors de l'exécution du programme le numéro de l'exercice qu'on veut exécuter,
à savoir 1 pour la diffusion séquentielle, 2 pour l'anneau séquentiel, et 3 pour la diffusion HyperCube

J'ai fait un makefile pour compiler et exécuter mon code. On peut directement exécuter un exercice en entrant "make 1" par exemple pour l'exercice 1.
\begin{verbatim}
CC = mpic++
OBJS = exercises.o
CFLAGS = -c -g -Wall
.PHONY = clean
tp2: main.cpp exercises.o
        $(CC) $(OBJS) main.cpp -o tp2
exercises.o: exercises.cpp
        $(CC) $(CFLAGS) exercises.cpp -o exercises.o
clean:
        rm $(OBJS) tp2
1: tp2
        mpirun tp2 1
2: tp2
        mpirun tp2 2
3: tp2
        mpirun tp2 3
\end{verbatim}
\subsection{Diffusion séquentielle}
\label{sec:org672931d}
Voilà l'output du programme de la diffusion séquentielle:
\begin{verbatim}
module load mpi
make 1
\end{verbatim}

\begin{verbatim}
mpic++ -c -g -Wall exercises.cpp -o exercises.o
mpic++ exercises.o main.cpp -o tp2
mpirun tp2 1
Message received by processor 1 from processor 0: Hello world !
Message received by processor 2 from processor 0: Hello world !
Message received by processor 3 from processor 0: Hello world !
\end{verbatim}


Ici, on veut que notre processeur 0 envoie un message aux autres processeurs\ldots{} On peut remarquer avec l'output que notre objectif a bien été atteint,
car on a bien le processeur 0 qui envoie un message à tous les autres processeurs.

\subsection{Anneau séquentiel}
\label{sec:org78cf21b}

Voilà l'output de l'anneau séquentiel

\begin{verbatim}
module load mpi
make 2
\end{verbatim}

\begin{verbatim}
mpirun tp2 2
Processor 3 receive from processor 2 the message: Hello World !
Processor 2 receive from processor 1 the message: Hello World !
Processor 1 receive from processor 0 the message: Hello World !
Processor 0 receive from processor 3 the message: Hello World !
\end{verbatim}


Ici, on peut voir que le processeur 1 a envoyé un message au processeur 2, qui a envoyé un message au processeur 3 etc\ldots{} Cela fait bien un cycle, donc on est content du résultat obtenu.

\subsection{Diffusion HyperCube}
\label{sec:org65b8a41}

Voilà l'output de la diffusion HyperCube
\begin{verbatim}
module load mpi
make 3
\end{verbatim}

\begin{verbatim}
mpirun tp2 3
Processor 0 received Hello world ! from processor 1
Processor 2 received Hello world ! from processor 3
Processor 0 received Hello world ! from processor 2
Processor 1 received Hello world ! from processor 3
\end{verbatim}



Ici, notre masque est d'abord égal à \(001\). Donc le processeur \(001 = 1\) envoie un message au processeur \(000 = 0\) et le processeur \(011 = 3\) envoie un message au processeur \(010 = 2\).
Puis notre masque est égal à \(010\). Donc le processeur \(010 = 2\) envoie un message au processeur \(000 = 0\) et le processeur \(011 = 3\) envoie un message au processeur \(001 = 1\).
Notre output est bien ce qu'on attend, donc on est content.

\section{Commentaires sur l'output}
\label{sec:orga286471}
blabla
\end{document}